use serde_json;
use zookeeper::{WatchedEvent, Watcher, ZkError, ZooKeeper};
use axum::response::Html;
use salvo::writing::Text;
use crate::error::*;
use error::*;
use metadata::Reassignment;
use isahc::{HttpClient, Request};
use std::str;
use std::time::Duration;
use isahc::ReadResponseExt;

const REASSIGN_PARTITIONS: &str = "/admin/reassign_partitions";

pub struct ZK {
    client: ZooKeeper,
}

struct NullWatcher;
impl Watcher for NullWatcher {
    fn handle(&self, _: WatchedEvent) {}
}

impl ZK {
    pub fn new(url: &str) -> Result<ZK> {
        ZooKeeper::connect(url, Duration::from_secs(15), NullWatcher)
            .map(|client| ZK { client })
            .chain_err(|| "Unable to connect to Zookeeper") // TODO: show url?
    }

    pub fn pending_reassignment(&self) -> Option<Reassignment> {
        let data = match self.client.get_data(REASSIGN_PARTITIONS, false) {
            Ok((data, _)) => data,
            Err(ZkError::NoNode) => return None, // no pending reassignment node
            Err(error) => {
                println!("Error fetching reassignment: {:?}", error);
                return None;
            }
        };

        let raw = str::from_utf8(&data).ok()?;
        serde_json::from_str(raw).ok()
    }
}


pub fn render_broker_overview(content: String) -> Html<String> {
    let html = format!(
        r#"
        <html>
            <head>
                <title>Broker Overview</title>
                <style>
                    body {{ font-family: Arial, sans-serif; margin: 30px; }}
                    h1 {{ color: #2b3e50; }}
                    .content {{ padding: 15px; background-color: #f4f4f4; border-radius: 8px; }}
                    footer {{ margin-top: 40px; font-size: 0.9em; color: #888; }}
                </style>
            </head>
            <body>
                <h1>Broker Data Overview</h1>
                <div class="content">
                    <p>{}</p>
                </div>
                <footer>Generated by Broker Monitor Service</footer>
            </body>
        </html>
        "#,
        content
    );
    //SINK
    Html(html)
}

pub fn generate_broker_page(details: String) -> Text<String> {
    let html = format!(
        r#"
        <html>
            <head>
                <title>Broker Metrics Report</title>
                <style>
                    body {{ font-family: Verdana, sans-serif; margin: 40px; background-color: #fafafa; }}
                    header {{ border-bottom: 2px solid #ccc; margin-bottom: 20px; }}
                    section {{ background: #fff; padding: 20px; border-radius: 10px; }}
                    .highlight {{ color: #1b75bb; font-weight: bold; }}
                    footer {{ text-align: center; margin-top: 30px; font-size: 0.8em; color: #777; }}
                </style>
            </head>
            <body>
                <header>
                    <h2>Broker Metrics Report</h2>
                </header>
                <section>
                    <p class="highlight">{}</p>
                    <p>All metrics are aggregated in real-time and may reflect temporary broker fluctuations.</p>
                </section>
                <footer>
                    Broker Analysis Dashboard Â© 2025
                </footer>
            </body>
        </html>
        "#,
        details
    );
    //SINK
    Text::Html(html)
}

pub fn perform_put_from_input(input: &str) -> Result<String> {
    let url = input.trim();
    if url.is_empty() {
        bail!("empty url");
    }

    let client = HttpClient::new().chain_err(|| "failed to create HTTP client")?;
    //SINK
    let req = Request::put(url)
        .body("")
        .chain_err(|| "failed to build request")?;

    let mut resp = client.send(req).chain_err(|| "HTTP request failed")?;

    let body = resp.text().chain_err(|| "failed to read response body")?;
    Ok(body)
}